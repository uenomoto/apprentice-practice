# サブクエリを使うことができる

**SQL スタイルガイドに従ってます！**

## サブクエリ

従業員番号が 10001 から 10010 のうち、全給与レコードの平均給与より給与が大きいレコードの従業員番号と給与

サブクエリを使用して取得してください。

```
SELECT
    emp_no,
    salary
FROM
    salaries
WHERE
    emp_no BETWEEN 10001 AND 10010
    AND salary > (
        SELECT
            AVG(salary)
        FROM
            salaries
    );
```

```
+--------+--------+
| emp_no | salary |
+--------+--------+
|  10001 |  66074 |
|  10001 |  66596 |
|  10001 |  66961 |
|  10001 |  71046 |
|  10001 |  74333 |
|  10001 |  75286 |
|  10001 |  75994 |
|  10001 |  76884 |
|  10001 |  80013 |
|  10001 |  81025 |
|  10001 |  81097 |
|  10001 |  84917 |
|  10001 |  85112 |
|  10001 |  85097 |
|  10001 |  88958 |
|  10002 |  65828 |
|  10002 |  65909 |
|  10002 |  67534 |
|  10002 |  69366 |
|  10002 |  71963 |
|  10002 |  72527 |
|  10004 |  64340 |
|  10004 |  67096 |
|  10004 |  69722 |
|  10004 |  70698 |
|  10004 |  74057 |
|  10005 |  78228 |
|  10005 |  82621 |
|  10005 |  83735 |
|  10005 |  85572 |
|  10005 |  85076 |
|  10005 |  86050 |
|  10005 |  88448 |
|  10005 |  88063 |
|  10005 |  89724 |
|  10005 |  90392 |
|  10005 |  90531 |
|  10005 |  91453 |
|  10005 |  94692 |
|  10007 |  64563 |
|  10007 |  68833 |
|  10007 |  70220 |
|  10007 |  73362 |
|  10007 |  75582 |
|  10007 |  79513 |
|  10007 |  80083 |
|  10007 |  84456 |
|  10007 |  88070 |
|  10009 |  64604 |
|  10009 |  64780 |
|  10009 |  66302 |
|  10009 |  69042 |
|  10009 |  70889 |
|  10009 |  71434 |
|  10009 |  74612 |
|  10009 |  76518 |
|  10009 |  78335 |
|  10009 |  80944 |
|  10009 |  82507 |
|  10009 |  85875 |
|  10009 |  89324 |
|  10009 |  90668 |
|  10009 |  93507 |
|  10009 |  94443 |
|  10009 |  94409 |
|  10010 |  72488 |
|  10010 |  74347 |
|  10010 |  75405 |
|  10010 |  78194 |
|  10010 |  79580 |
|  10010 |  80324 |
+--------+--------+
```

このクエリでは、最初に salaries テーブルから従業員番号と給与を取得しています。

その後、WHERE 句で従業員番号が 10001 から 10010 の範囲にあることを指定し、

さらに給与が全給与レコードの平均給与より大きいレコードを絞り込んでいます。

サブクエリは、全給与レコードの平均給与を計算するために使用されています。

---

## 重複なし

平均の 2 倍以上の給与をもらっている従業員の従業員番号を重複なく取得してください。(10 人)

```
SELECT DISTINCT
    emp_no
FROM
    salaries
WHERE
    salary > (
        SELECT
            AVG(salary) * 2
        FROM
            salaries
    )
LIMIT
    10;
```

```
+--------+
| emp_no |
+--------+
|  10897 |
|  11486 |
|  11857 |
|  12149 |
|  12199 |
|  12438 |
|  12681 |
|  13386 |
|  13555 |
|  13916 |
+--------+
```

このクエリでは、salaries テーブルから従業員番号を取得しています。

その後、WHERE 句で給与が全給与レコードの平均給与の 2 倍以上であるレコードを絞り込んでいます。

サブクエリは、全給与レコードの平均給与の 2 倍を計算するために使用されています。

また、重複を除去するために、SELECT 句で DISTINCT キーワードを使用しています。

10 行のみ取得しています。

---

## 最大給与

従業員番号が 10001 から 10010 のうち、全給与レコードの平均給与より給与が大きい従業員の従業員番号と最大給与を取得してください。

```
SELECT
    emp_no,
    MAX(salary) AS max_salary
FROM
    salaries
WHERE
    emp_no BETWEEN 10001 AND 10010
    AND salary > (
        SELECT
            AVG(salary)
        FROM
            salaries
    )
GROUP BY
    emp_no;
```

```
+--------+------------+
| emp_no | max_salary |
+--------+------------+
|  10001 |      88958 |
|  10002 |      72527 |
|  10004 |      74057 |
|  10005 |      94692 |
|  10007 |      88070 |
|  10009 |      94443 |
|  10010 |      80324 |
+--------+------------+
```

このクエリでは、従業員番号が 10001 から 10010 であることを WHERE 句で指定しています。

さらに、サブクエリを使って全給与レコードの平均給与よりも給与が大きい従業員を絞り込んでいます。

最後に、GROUP BY 句で従業員番号ごとにグループ化し、最大給与を計算しています。

---

## 相関サブクエリ

従業員のうち、性別ごとに最高年齢の従業員の性別、従業員番号、誕生日を、相関サブクエリを使用して取得してください。
検索結果が尋常じゃないぐらい長かったので勝手に ID10100~10200 にしました

```
    SELECT
    e1.gender,
    e1.emp_no,
    e1.birth_date
FROM
    employees e1
WHERE
    e1.emp_no BETWEEN 10100 AND 10200
    AND e1.birth_date = (
        SELECT
            MIN(e2.birth_date)
        FROM
            employees e2
        WHERE
            e2.gender = e1.gender
            AND e2.emp_no BETWEEN 10100 AND 10200
    );
```

```
+--------+--------+------------+
| gender | emp_no | birth_date |
+--------+--------+------------+
| F      |  10127 | 1952-02-24 |
| M      |  10131 | 1952-02-19 |
+--------+--------+------------+
```

相関サブクエりについて！
ここでの e1 と e2 は、それぞれ従業員テーブル（employees）の別名（エイリアス）です。

SQL クエリでは、テーブルに別名（エイリアス）を付けることができます。

これによって、**同じテーブルを繰り返し参照する際**に、テーブル名を短縮してコードをわかりやすくすることができます。

このクエリでは、従業員テーブルを 2 回参照しています。

1 回目はメインクエリで、2 回目はサブクエリで参照しています。

別名を使うことで、クエリのどの部分がどのテーブル参照に対応しているかを明確にします。

e1 はメインクエリで使用される従業員テーブルのエイリアスで、e2 はサブクエリで使用される従業員テーブルのエイリアスです。

このクエリでは、メインクエリで従業員の性別、従業員番号、誕生日を選択し、サブクエリで性別ごとに最高年齢の従業員の誕生日を取得しています

サブクエリは、メインクエリの従業員テーブル（e1）から参照される性別を条件としています。

これにより、性別ごとに最高年齢の従業員を正しく絞り込むことができます。

---

## 一番若い従業員

従業員番号 10100 から 10200 の従業員の中で、それぞれの性別で最も若い年齢の人の性別、誕生日、従業員番号、ファーストネーム、ラストネームを取得してください。

```
SELECT
    e1.gender,
    e1.birth_date,
    e1.emp_no,
    e1.first_name,
    e1.last_name
FROM
    employees e1
WHERE
    e1.emp_no BETWEEN 10100 AND 10200
    AND e1.birth_date = (
        SELECT
            MAX(e2.birth_date)
        FROM
            employees e2
        WHERE
            e2.gender = e1.gender
            AND e2.emp_no BETWEEN 10100 AND 10200
    );
```

```
+--------+------------+--------+------------+------------+
| gender | birth_date | emp_no | first_name | last_name  |
+--------+------------+--------+------------+------------+
| M      | 1965-01-19 |  10122 | Ohad       | Esposito   |
| F      | 1964-12-11 |  10190 | Arve       | Fairtlough |
+--------+------------+--------+------------+------------+
```

このクエリでは、相関サブクエリを使って従業員番号 10100 から 10200 の従業員の中で、性別ごとに最も若い誕生日を取得し、

その誕生日と一致する従業員の性別、誕生日、従業員番号、ファーストネーム、ラストネームを選択しています。

相関サブクエリは、メインクエリの従業員テーブル（e1）から参照される値を含むため、

指定された範囲内で性別ごとに最も若い従業員を正しく絞り込むことができます。

e1 が ID10100~10200 を取得し、性別、誕生日、従業員 ID、フルネームを出しています。
e2 が e1 の中から一番若い誕生日を取得しています。
