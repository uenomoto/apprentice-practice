# インデックスを設定できる

## インデックス設定前

employees データベースの employees テーブルに対して、誕生日が 1961 年 8 月 3 日のレコードを取得してください。

その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測してください。

```
EXPLAIN ANALYZE
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
```

```
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                                      |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (employees.birth_date = DATE'1961-08-03')  (cost=30161 rows=29929) (actual time=97.1..1053 rows=67 loops=1)
    -> Table scan on employees  (cost=30161 rows=299290) (actual time=1.98..912 rows=300024 loops=1)
 |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (1.09 sec)
```

1.09 秒

---

## インデックスの作成

employees データベースの employees テーブルの birth_date カラムにインデックスを作成してください。

```
CREATE INDEX idx_birth_date ON employees(birth_date);
```

これでインデックスが作成されます

---

## インデックスの確認

employees データベースの employees テーブルのインデックスを確認し、インデックスが作成されていることを確認してください。

```
SHOW INDEX FROM employees;
```

```
+-----------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table     | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-----------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| employees |          0 | PRIMARY        |            1 | emp_no      | A         |      299290 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| employees |          1 | idx_birth_date |            1 | birth_date  | A         |        4804 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-----------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
```

employees テーブルのインデックスが表示されます。

プライマリーキー(主キー)と idx_birth_date があるのが確認できます。

---

## インデックスの効果の確認

1 と同じクエリを実行してください。その際に、EXPLAIN ANALYZE ステートメントを利用することで、

実行時間を計測し、実行が高速化されていることを確認してください。

```
EXPLAIN ANALYZE
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
```

```
+------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                        |
+------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Index lookup on employees using idx_birth_date (birth_date=DATE'1961-08-03')  (cost=23.4 rows=67) (actual time=3.62..3.96 rows=67 loops=1)
 |
+------------------------------------------------------------------------------------------------------------------------------------------------
1 row in set (0.03 sec)
```

1.09 秒から 0.03 秒になりました。

---

## インデックスの説明

データベースはテーブルに格納されたデータに対して検索や更新を行いますが、インデックスがない場合、

検索する際にはテーブルのすべてのレコードを順番に調べる必要があります。これは本の中から特定の単語を探すことを想像してみてください。

インデックスがない場合、本の最初から最後までページをめくりながら単語を探さなければなりません。これは非常に時間がかかります。

しかし、インデックスがある場合、データベースは検索対象のデータを効率的に見つけることができます。

インデックスは、データの一部（検索に使われる列）とそのデータが格納されている場所へのポインタを持っています。

これは本の索引（目次）のようなものです。索引を使えば、特定の単語がどのページにあるかすぐにわかり、すぐにそのページを開くことができます。

同様に、データベースのインデックスは、検索に必要なデータを迅速に特定し、そのデータが格納されている場所にアクセスする手助けをします。

これにより、データベースが全てのレコードを調べる必要がなくなり、クエリの実行速度が向上します。

ただし、インデックスはデータの追加や更新にはオーバーヘッドがかかるため、適切なバランスを取ることが重要です。

インデックスは、頻繁に検索される列や、WHERE 句や JOIN 条件で使用される列に適用することが一般的です。

---

## インデックスの削除

インデックスを削除するには、DROP INDEX ステートメントを使用します。

```
DROP INDEX idx_birth_date ON employees;
```

```
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

これにより、employees テーブルの birth_date カラムに作成されたインデックスが削除されます。

今回はいいが実際に作るアプリの結果を見ながら削除は慎重に。

---

## ベストプラクティス

インデックスは適切に作成されると、データベースのパフォーマンスが向上しますが、作成すればするほど良いというものではありません。

インデックスを過剰に作成すると、データの追加や更新が遅くなったり、ディスク容量の無駄になることがあります

作成のベストプラクティスを以下にまとめます。

1. WHERE 句や JOIN 操作で頻繁に使われる列にインデックスを作成する:
   クエリで頻繁に使用される列にインデックスを作成することで、検索性能が大幅に向上します。

   この方法は、データベースのパフォーマンスを効果的に向上させるために広く利用されています。

---

2. カーディナリティが高い列にインデックスを作成する:
   カーディナリティが高い列、つまり一意の値が多い列にインデックスを作成することで、検索性能が向上します。

   カーディナリティが高い列ほど、インデックスの効果が大きいため、この方法もよく使われています。

---

これらの方法は、データベースのパフォーマンスを向上させる上で非常に効果的であり、

インデックス設計の際に最も重要なポイントとされています。
