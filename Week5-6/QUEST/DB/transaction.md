## トランザクションについて説明できる

## トランザクション

トランザクションとは、データベースにおいて一連の操作をひとまとめにし、データの整合性と安全性を保つための仕組みです。

トランザクションは、複数のデータ操作（挿入、更新、削除など）が一連の流れとして実行され、すべての操作が成功するか、

失敗した場合はすべての操作が取り消される（ロールバックされる）ように設計されています。

トランザクションがある理由は、データベースの整合性と安全性を保つためです。

複数の操作が行われる際に、途中でエラーや問題が発生した場合でも、トランザクションによってデータベースは安全な状態に戻されます。

これにより、データが破損したり、不整合な状態になるのを防ぎます。

例えば、銀行システムでは、お金の送金を行う際に、送金元の口座からお金を引き出し、

送金先の口座にお金を入れるという二つの操作が一連の流れとして実行されます。トランザクションを使用することで、

送金元からお金が引き出された後、送金先への入金が何らかの理由で失敗した場合、

送金元の口座へお金が戻るようにロールバックされます。これにより、データの整合性が保たれるのです。

まとめ
トランザクションとは、データベースでの一連の操作をまとめて、データを安全に管理するための仕組みです。

何か問題が起きた場合に、操作を元に戻すことができるので、データが壊れたり、おかしくなるのを防ぎます。

これがあるおかげで、たとえば銀行でお金を送るときに、安全にお金を移動できるようになっています。

---

## トランザクションの実行

employees データベースに接続してください。次に、トランザクションを実行してください。

```
START TRANSACTION;
```

ここから、新しい従業員と給料情報を追加します。

---

## ロールバック

任意のテーブルにデータを追加してください。

新しい従業員と給料情報を追加します。

```
-- トランザクションを開始
START TRANSACTION;

-- 新しい従業員を追加
INSERT INTO employees (emp_no, birth_date, first_name, last_name, gender, hire_date)
VALUES (500000, '1990-01-01', 'Taro', 'Yamada', 'M', '2023-05-01');

-- 新しい従業員の給与情報を追加
INSERT INTO salaries (emp_no, salary, from_date, to_date)
VALUES (500000, 60000, '2023-05-01', '9999-01-01');

-- トランザクションをコミット（確定）
COMMIT;
```

---

検索を実行し、データが追加されていることを確認してください。

```
SELECT *
FROM employees
WHERE emp_no IN(500000) ;
```

```
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
| 500000 | 1990-01-01 | Taro       | Yamada    | M      | 2023-05-01 |
+--------+------------+------------+-----------+--------+------------+
```

```
SELECT *
    -> FROM salaries
    -> WHERE emp_no IN(500000) ;
+--------+--------+------------+------------+
| emp_no | salary | from_date  | to_date    |
+--------+--------+------------+------------+
| 500000 |  60000 | 2023-05-01 | 9999-01-01 |
+--------+--------+------------+------------+
1 row in set (0.01 sec)
```

一気に検索！

```
SELECT *
FROM employees e
JOIN salaries s ON e.emp_no = s.emp_no
WHERE e.emp_no = 500000;
```

```
+--------+------------+------------+-----------+--------+------------+--------+--------+------------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  | emp_no | salary | from_date  | to_date    |
+--------+------------+------------+-----------+--------+------------+--------+--------+------------+------------+
| 500000 | 1990-01-01 | Taro       | Yamada    | M      | 2023-05-01 | 500000 |  60000 | 2023-05-01 | 9999-01-01 |
+--------+------------+------------+-----------+--------+------------+--------+--------+------------+------------+
```

---

次に、ロールバックを実行してください。検索を実行し、データの追加がされていないことを確認してください。

```
START TRANSACTION;

INSERT INTO employees (emp_no, birth_date, first_name, last_name, gender, hire_date)
VALUES (500001, '1990-01-01', 'Roll', 'BACK', 'M', '2023-01-01');
```

検索すると今は確認できます。

```
SELECT * FROM employees WHERE emp_no = 500001;
```

**コミット（確定しないでロールバックをすると？）**

```
ROLLBACK;
```

```
SELECT * FROM employees WHERE emp_no = 500001;
Empty set (0.01 sec)
```

このように DB から削除されているのが確認できます。

自分の場合バリデーションエラーがかかるとロールバックが行われているところを何度か見たことがあります。

---

## コミット

追加してコミットするとロールバックしても保存されてるのが確認できます

```
COMMIT;
```
