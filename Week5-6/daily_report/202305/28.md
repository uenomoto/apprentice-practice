# 2023/05/22(月)

## 本日の目標（TODO 目標/できるようになりたいこと）

スッキリわかる SQL 入門

テーブル設計途中まで

## 学習時間（Hour）

- today: 3h
- total: 278h

## 学んだこと（新しい気付き、学び）

### 外部キーと参照整合性

外部キーが指し示す先にあるべき行が存在してリレーションシップが成立して

いることを参照整合性という！

### 参照整合性の崩壊(違反)

外部キーで紐づいている ID が存在しない状態のことを言う

この様な状態になることは避けなければならない

原因

- 他の行から参照されている行を削除
- 他の行から参照されている行の主キーを削除
- 存在しない行を参照する行を追加してしまう
- 存在しない行を参照する行に更新してしまう

## インデックスの作成と削除

索引情報はインデックスと呼ばれる！

インデックスの特徴

- インデックスは、指定した列にたいして作られる
- インデックスが存在する列に対して検索が行われると DBMS は

自動的にインデックスの使用を試みるため、高速になる場合が多い！

- インデックスには名前をつけること！

インデックス作成基本構文

`CREATE INDEX インデックス名 ON テーブル名(カラム名)`

因みにインデックス名は**重複しない範囲で任意の名前**をつけることができる！

この名前は、`DROP INDEX`文でインデックス削除する時に使う！

インデックス削除基本構文

`DROP INDEX インデックス名 ON テーブル名`

複数の列を 1 つのインデックスとする複合インデックスも作成可能！

---

### 効果を得られやすい典型的な 3 つのケース

### WHERE 句による絞り込み

そのカラムに対してサーチ機能があったとしたらインデックスつけた方がいい

### ORDER BY による並び替え

インデックスには並び替えを高速化する効果もある！！

### JOIN による結合の条件

### インデックス設定の効果が得られやすいカラム

- WHERE 句にに頻繁に登場するカラム
- ORDER BY 句に頻繁に登場するカラム
- JOIN による結合条件に頻繁に登場するカラム(外部キーカラム)

### インデックスの注意点

### インデックスは乱用しない

やたら無闇にインデックスつけるのは NG!

検索性能は向上するが、書き換え時のオーバーヘッドは増加する。

### インデックス作成することによるデメリット

- 索引情報を保存するために、ディスク容量を消費する
- テーブルのデータが変更されるとインデックスも書き換える必要があるため

INSERT 分、UPDATE 文、DELETE 文のオーバーヘッドが増える

**簡単にいうとテーブルデータが変更されるとインデックスも書き換えなければならない。**

EXPLAIN PLAN 文を使ってインデックスによって処理がどれくらい早くなるか目安を確認することができる！

---

### ACID 特性

- 原子性: 処理が中断しても中途半端な状態にならない(ロールバック)
- 一貫性: データの内容が矛盾した状態にならない(参照整合性)
- 分離性: 複数の処理を同時実行しても副作用がない(ロック)
- 永続性: 記録した情報は消滅せずに保持され続ける(バックアップから復元後ログからロールフォワード)

## 感想（一日の感想、雑談）

お子さんがいて平日仕事している方で勉強している方本当に尊敬します！

朝の３時間しかできなかったです。

休みの日はうるさいし定期的に部屋来るしで集中できない w(しょうがないんですけどね！)

その分平日でガチる！

## 明日の目標（TODO 目標/できるようになりたいこと）

スッキリ SQL 入門のテーブル作成の章の続きから
